var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"},{"location":"#Solvers","page":"Home","title":"Solvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AMGSolver\nRLXSolver","category":"page"},{"location":"#AMGCLWrap.AMGSolver","page":"Home","title":"AMGCLWrap.AMGSolver","text":"AMGSolver(sparsematrix::AbstractSparseMatrix; \n             blocksize=1, \n             param=nothing)\n\nCreate Algebraic multigrid preconditioned Krylov subspace solver with ldiv! and \\ methods solving the matrix system.\n\nParameters:\n\nsparsematrix: SparseArrays.AbstractSparseMatrixCSC or SparseMatricesCSR.SparseMatrixCSR. \nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of        blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nparam: Any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write. If params is an emtpy string or nothing a default value is used.\n\n\n\n\n\nAMGSolver(sparsematrix::AbstractSparseMatrix;\n          blocksize::Int=1,\n          param=nothing,\n          verbose::Bool=false,\n          coarsening::Union{AbstractCoarsening, NamedTuple}=SmoothedAggregationCoarsening(),\n          relax::Union{AbstractRelaxation, NamedTuple}=SPAI0Relaxation(),\n          solver::Union{AbstractSolver, NamedTuple}=BICGStabSolver(;verbose))\n\nCreate Algebraic multigrid preconditioned Krylov subspace solver with ldiv! and \\ methods solving the matrix system.\n\nParameters:\n\nsparsematrix: SparseArrays.AbstractSparseMatrixCSC or SparseMatricesCSR.SparseMatrixCSR. \nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of        blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nparam:   Ignored if nothing (default). Otherwise, any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write.\nverbose: if true, print generated JSON string passed to amgcl.\ncoarsening: A coarsening strategy\nrelax: A relaxation method\nsolver: An iterative solver\n\n\n\n\n\n","category":"type"},{"location":"#AMGCLWrap.RLXSolver","page":"Home","title":"AMGCLWrap.RLXSolver","text":"RLXSolver(sparsematrix::AbstractSparseMatrix; \n             blocksize=1, \n             param=nothing)\n\nCreate single level relaxation preconditioned Krylov subspace solver with ldiv! and \\ methods solving the matrix system.\n\nParameters:\n\nsparsematrix: SparseArrays.AbstractSparseMatrixCSC or SparseMatricesCSR.SparseMatrixCSR. \nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of        blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nparam: Any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write. If params is an emtpy string or nothing a default value is used.\n\n\n\n\n\nRLXSolver(sparsematrix::AbstractSparseMatrix;\n          blocksize::Int=1,\n          param=nothing,\n          verbose::Bool=false,\n          precond::Union{AbstractRelaxation, NamedTuple}=SPAI0Relaxation(),\n          solver::Union{AbstractSolver, NamedTuple}=BICGStabSolver(;verbose))\n\nCreate single level relaxation preconditioned Krylov subspace solver with ldiv! and \\ methods solving the matrix system.\n\nParameters:\n\nsparsematrix: SparseArrays.AbstractSparseMatrixCSC or SparseMatricesCSR.SparseMatrixCSR. \nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of        blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nparam:   Ignored if nothing (default). Otherwise, any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write.\nverbose: if true, print generated JSON string passed to amgcl.\nprecond: A preconditioned method\nsolver: An iterative solver\n\n\n\n\n\n","category":"type"},{"location":"#Preconditioners","page":"Home","title":"Preconditioners","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AMGPrecon\nRLXPrecon","category":"page"},{"location":"#AMGCLWrap.AMGPrecon","page":"Home","title":"AMGCLWrap.AMGPrecon","text":"AMGPrecon(sparsematrix::AbstractSparseMatrix; \n             blocksize=1, \n             param=nothing)\n\nCreate algebraic multigrid preconditioner with ldiv! and \\ methods solving the preconditioning system.\n\nParameters:\n\nsparsematrix: SparseArrays.AbstractSparseMatrixCSC or SparseMatricesCSR.SparseMatrixCSR. \nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of        blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nparam: Any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write. If params is an emtpy string or nothing a default value is used.\n\n\n\n\n\nAMGPrecon(sparsematrix::AbstractSparseMatrix;              blocksize::Int=1,              param=nothing,              verbose::Bool=false,              coarsening::Union{AbstractCoarsening, NamedTuple}=SmoothedAggregationCoarsening(),              relax::Union{AbstractRelaxation, NamedTuple}=SPAI0Relaxation()) Create algebraic multigrid preconditioner with ldiv! and \\ methods solving the preconditioning system.\n\nParameters:\n\nsparsematrix: SparseArrays.AbstractSparseMatrixCSC or SparseMatricesCSR.SparseMatrixCSR. \nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of        blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nparam:   Ignored if nothing (default). Otherwise, any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write.\nverbose: if true, print generated JSON string passed to amgcl.\ncoarsening: A coarsening strategy\nrelax: A relaxation method\n\n\n\n\n\n","category":"type"},{"location":"#AMGCLWrap.RLXPrecon","page":"Home","title":"AMGCLWrap.RLXPrecon","text":"RLXPrecon(sparsematrix::AbstractSparseMatrix; \n             blocksize=1, \n             param=nothing)\n\nCreate single level relaxation preconditioner with ldiv! and \\ methods solving the preconditioning system.\n\nParameters:\n\nsparsematrix: SparseArrays.AbstractSparseMatrixCSC or SparseMatricesCSR.SparseMatrixCSR. \nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of        blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nparam: Any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write. If params is an emtpy string or nothing a default value is used.\n\n\n\n\n\nRLXPrecon(sparsematrix::AbstractSparseMatrix;\n          blocksize::Int=1,\n          param=nothing,\n          verbose::Bool=false,\n          precond::Union{AbstractRelaxation, NamedTuple}=SPAI0Relaxation())\n\nCreate single level relaxation preconditioner with ldiv! and \\ methods solving the preconditioning system.\n\nParameters:\n\nsparsematrix: SparseArrays.AbstractSparseMatrixCSC or SparseMatricesCSR.SparseMatrixCSR. \nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of        blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nparam:   Ignored if nothing (default). Otherwise, any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write.\nverbose: if true, print generated JSON string passed to amgcl.\nprecond: A preconditioned method\n\n\n\n\n\n","category":"type"},{"location":"#General-tools","page":"Home","title":"General tools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"error_state\nblocksize_instantiated","category":"page"},{"location":"#AMGCLWrap.error_state","page":"Home","title":"AMGCLWrap.error_state","text":"error_state(operator)::Int\n\nReturn error state of operator. Ok if 0.\n\n\n\n\n\n","category":"function"},{"location":"#AMGCLWrap.blocksize_instantiated","page":"Home","title":"AMGCLWrap.blocksize_instantiated","text":"blocksize_instantiated(blocksize)::Bool\n\nCheck if given blocksize has been instantiated.\n\n\n\n\n\n","category":"function"},{"location":"#Parameters","page":"Home","title":"Parameters","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AMGCLWrap.AbstractAMGCLParams","category":"page"},{"location":"#AMGCLWrap.AbstractAMGCLParams","page":"Home","title":"AMGCLWrap.AbstractAMGCLParams","text":"abstract type AbstractAMGCLParams\n\nAbstract parameter type.\n\n\n\n\n\n","category":"type"},{"location":"#Solver-parameters","page":"Home","title":"Solver parameters","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Iterative Solvers section of the AMGCL documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Instead of one of the solvers below, a named tuple like (type= \"cg\", tol=1.0e-10) can be passed This also allows to use methods not accessible via one of the structures defined below. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"AMGCLWrap.AbstractSolver\nAMGCLWrap.BICGStabSolver\nAMGCLWrap.CGSolver\nAMGCLWrap.GMRESSolver","category":"page"},{"location":"#AMGCLWrap.AbstractSolver","page":"Home","title":"AMGCLWrap.AbstractSolver","text":"abstract type AbstractSolver <: AMGCLWrap.AbstractAMGCLParams\n\nAbstract solver parameter type.\n\n\n\n\n\n","category":"type"},{"location":"#AMGCLWrap.BICGStabSolver","page":"Home","title":"AMGCLWrap.BICGStabSolver","text":"struct BICGStabSolver <: AMGCLWrap.AbstractSolver\n\nBICGStab solver\n\ntype::String\npside::String\ntol::Float64\nabstol::Float64\nmaxiter::Int64\nverbose::Bool\n\n\n\n\n\n","category":"type"},{"location":"#AMGCLWrap.CGSolver","page":"Home","title":"AMGCLWrap.CGSolver","text":"struct CGSolver <: AMGCLWrap.AbstractSolver\n\ntype::String\ntol::Float64\nabstol::Float64\nmaxiter::Int64\nverbose::Bool\n\n\n\n\n\n","category":"type"},{"location":"#AMGCLWrap.GMRESSolver","page":"Home","title":"AMGCLWrap.GMRESSolver","text":"struct GMRESSolver <: AMGCLWrap.AbstractSolver\n\ntype::String\nM::Int64\npside::String\ntol::Float64\nabstol::Float64\nmaxiter::Int64\nverbose::Bool\n\n\n\n\n\n","category":"type"},{"location":"#Relaxation/Preconditioner-parameters","page":"Home","title":"Relaxation/Preconditioner parameters","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Relaxation section of the AMGCL documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Instead of one of the strategies below, a named tuple like (type= \"damped_jacobi\", damping=0.72) can be passed This also allows to use methods not accessible via one of the structures defined below. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"AMGCLWrap.AbstractRelaxation\nAMGCLWrap.ILU0Relaxation\nAMGCLWrap.SPAI0Relaxation","category":"page"},{"location":"#AMGCLWrap.AbstractRelaxation","page":"Home","title":"AMGCLWrap.AbstractRelaxation","text":"abstract type AbstractRelaxation <: AMGCLWrap.AbstractAMGCLParams\n\nAbstract relaxation parameter type.\n\n\n\n\n\n","category":"type"},{"location":"#AMGCLWrap.ILU0Relaxation","page":"Home","title":"AMGCLWrap.ILU0Relaxation","text":"struct ILU0Relaxation <: AMGCLWrap.AbstractRelaxation\n\ntype::String\n\n\n\n\n\n","category":"type"},{"location":"#AMGCLWrap.SPAI0Relaxation","page":"Home","title":"AMGCLWrap.SPAI0Relaxation","text":"struct SPAI0Relaxation <: AMGCLWrap.AbstractRelaxation\n\ntype::String\n\n\n\n\n\n","category":"type"},{"location":"#Coarsening-strategies","page":"Home","title":"Coarsening strategies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Coarsening Strategies section of the AMGCL documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Instead of one of the strategies below, a named tuple like (type= \"smoothed_aggregation\", relax=1.0) can be passed This also allows to use methods not accessible via one of the structures defined below. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"AMGCLWrap.AbstractCoarsening\nAMGCLWrap.RugeStubenCoarsening\nAMGCLWrap.SmoothedAggregationCoarsening","category":"page"},{"location":"#AMGCLWrap.AbstractCoarsening","page":"Home","title":"AMGCLWrap.AbstractCoarsening","text":"abstract type AbstractCoarsening <: AMGCLWrap.AbstractAMGCLParams\n\nAbstract coarsening parameter type.\n\n\n\n\n\n","category":"type"},{"location":"#AMGCLWrap.RugeStubenCoarsening","page":"Home","title":"AMGCLWrap.RugeStubenCoarsening","text":"struct RugeStubenCoarsening <: AMGCLWrap.AbstractCoarsening\n\ntype::String\neps_strong::Float64\ndo_trunc::Bool\neps_trunc::Float64\n\n\n\n\n\n","category":"type"},{"location":"#AMGCLWrap.SmoothedAggregationCoarsening","page":"Home","title":"AMGCLWrap.SmoothedAggregationCoarsening","text":"struct SmoothedAggregationCoarsening <: AMGCLWrap.AbstractCoarsening\n\ntype::String\nrelax::Float64\n\n\n\n\n\n","category":"type"}]
}
