var documenterSearchIndex = {"docs":
[{"location":"misc/#Misc-tools","page":"Misc tools","title":"Misc tools","text":"","category":"section"},{"location":"misc/","page":"Misc tools","title":"Misc tools","text":"error_state\nblocksize_instantiated","category":"page"},{"location":"misc/#AMGCLWrap.error_state","page":"Misc tools","title":"AMGCLWrap.error_state","text":"error_state(operator)::Int\n\nReturn error state of operator. Ok if 0.\n\n\n\n\n\n","category":"function"},{"location":"misc/#AMGCLWrap.blocksize_instantiated","page":"Misc tools","title":"AMGCLWrap.blocksize_instantiated","text":"blocksize_instantiated(blocksize)::Bool\n\nCheck if given blocksize has been instantiated.\n\n\n\n\n\n","category":"function"},{"location":"solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers/#Standalone","page":"Solvers","title":"Standalone","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"AMGSolver\nRLXSolver","category":"page"},{"location":"solvers/#AMGCLWrap.AMGSolver","page":"Solvers","title":"AMGCLWrap.AMGSolver","text":"AMGSolver(sparsematrix::AbstractSparseMatrix; \n             blocksize=1, \n             param=nothing)\n\nCreate Algebraic multigrid preconditioned Krylov subspace solver with ldiv! and \\ methods solving the matrix system.\n\nParameters:\n\nsparsematrix: SparseArrays.AbstractSparseMatrixCSC or SparseMatricesCSR.SparseMatrixCSR. \nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of        blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nparam: Any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write. If params is an emtpy string or nothing a default value is used.\n\n\n\n\n\nAMGSolver(sparsematrix::AbstractSparseMatrix;\n          blocksize::Int=1,\n          param=nothing,\n          verbose::Bool=false,\n          coarsening::Union{AbstractCoarsening, NamedTuple}=SmoothedAggregationCoarsening(),\n          relax::Union{AbstractRelaxation, NamedTuple}=SPAI0Relaxation(),\n          solver::Union{AbstractSolver, NamedTuple}=BICGStabSolver(;verbose))\n\nCreate Algebraic multigrid preconditioned Krylov subspace solver with ldiv! and \\ methods solving the matrix system.\n\nParameters:\n\nsparsematrix: SparseArrays.AbstractSparseMatrixCSC or SparseMatricesCSR.SparseMatrixCSR. \nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nverbose: if true, print generated JSON string passed to amgcl.\nparam:   Ignored if nothing (default). Otherwise, any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write.\ncoarsening: One of the  Coarsening strategies\nrelax: One of the Relaxation strategies\nsolver: One of the Iterative solver strategies\n\n\n\n\n\n","category":"type"},{"location":"solvers/#AMGCLWrap.RLXSolver","page":"Solvers","title":"AMGCLWrap.RLXSolver","text":"RLXSolver(sparsematrix::AbstractSparseMatrix; \n             blocksize=1, \n             param=nothing)\n\nCreate single level relaxation preconditioned Krylov subspace solver with ldiv! and \\ methods solving the matrix system.\n\nParameters:\n\nsparsematrix: SparseArrays.AbstractSparseMatrixCSC or SparseMatricesCSR.SparseMatrixCSR. \nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of        blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nparam: Any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write. If params is an emtpy string or nothing a default value is used.\n\n\n\n\n\nRLXSolver(sparsematrix::AbstractSparseMatrix;\n          blocksize::Int=1,\n          param=nothing,\n          verbose::Bool=false,\n          precond::Union{AbstractRelaxation, NamedTuple}=ILU0Relaxation(),\n          solver::Union{AbstractSolver, NamedTuple}=BICGStabSolver(;verbose))\n\nCreate single level relaxation preconditioned Krylov subspace solver with ldiv! and \\ methods solving the matrix system.\n\nParameters:\n\nsparsematrix: SparseArrays.AbstractSparseMatrixCSC or SparseMatricesCSR.SparseMatrixCSR. \nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nverbose: if true, print generated JSON string passed to amgcl.\nparam:   Ignored if nothing (default). Otherwise, any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write.\nprecond: One of the Relaxation strategies seen as preconditioner\nsolver: One of the Iterative solver strategies\n\n\n\n\n\n","category":"type"},{"location":"solvers/#LinearSolve-algorithms","page":"Solvers","title":"LinearSolve algorithms","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"AMGSolverAlgorithm\nRLXSolverAlgorithm","category":"page"},{"location":"solvers/#AMGCLWrap.AMGSolverAlgorithm","page":"Solvers","title":"AMGCLWrap.AMGSolverAlgorithm","text":"AMGSolverAlgorithm(;blocksize::Int=1,\n                    param=nothing,\n                    verbose::Bool=false,\n                    coarsening::Union{AbstractCoarsening, NamedTuple}=SmoothedAggregationCoarsening(),\n                    relax::Union{AbstractRelaxation, NamedTuple}=SPAI0Relaxation(),\n                    solver::Union{AbstractSolver, NamedTuple}=BICGStabSolver(;verbose))\n\nAlgebraic multigrid preconditioned Krylov subspace solver algorithm for LinearSolve.jk Parameters:\n\nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nverbose: if true, print generated JSON string passed to amgcl.\nparam:   Ignored if nothing (default). Otherwise, any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write.\ncoarsening: One of the  Coarsening strategies\nrelax: One of the Relaxation strategies\nsolver: One of the Iterative solver strategies\n\n\n\n\n\n","category":"function"},{"location":"solvers/#AMGCLWrap.RLXSolverAlgorithm","page":"Solvers","title":"AMGCLWrap.RLXSolverAlgorithm","text":"RLXSolverAlgorithm(;blocksize::Int=1,\n                    param=nothing,\n                    verbose::Bool=false,\n                    precond::Union{AbstractRelaxation, NamedTuple}=ILU0Relaxation(),\n                    solver::Union{AbstractSolver, NamedTuple}=BICGStabSolver(;verbose))\n\nAlgebraic multigrid preconditioned Krylov subspace solver algorithm for LinearSolve.jk Parameters:\n\nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nverbose: if true, print generated JSON string passed to amgcl.\nparam:   Ignored if nothing (default). Otherwise, any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write.\nprecond: One of the Relaxation strategies seen as preconditioner\nsolver: One of the Iterative solver strategies\n\n\n\n\n\n","category":"function"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"using Markdown\nMarkdown.parse(read(\"../../CHANGELOG.md\",String))","category":"page"},{"location":"preconditioners/#Preconditioners","page":"Preconditioners","title":"Preconditioners","text":"","category":"section"},{"location":"preconditioners/","page":"Preconditioners","title":"Preconditioners","text":"AMGPrecon\nAMGPreconditioner\nRLXPrecon\nRLXPreconditioner","category":"page"},{"location":"preconditioners/#AMGCLWrap.AMGPrecon","page":"Preconditioners","title":"AMGCLWrap.AMGPrecon","text":"AMGPrecon(sparsematrix::AbstractSparseMatrix; \n             blocksize=1, \n             param=nothing)\n\nCreate algebraic multigrid preconditioner with ldiv! and \\ methods solving the preconditioning system.\n\nParameters:\n\nsparsematrix: SparseArrays.AbstractSparseMatrixCSC or SparseMatricesCSR.SparseMatrixCSR. \nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of        blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nparam: Any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write. If params is an emtpy string or nothing a default value is used.\n\n\n\n\n\nAMGPrecon(sparsematrix::AbstractSparseMatrix;              blocksize::Int=1,              param=nothing,              verbose::Bool=false,              coarsening::Union{AbstractCoarsening, NamedTuple}=SmoothedAggregationCoarsening(),              relax::Union{AbstractRelaxation, NamedTuple}=SPAI0Relaxation()) Create algebraic multigrid preconditioner with ldiv! and \\ methods solving the preconditioning system.\n\nParameters:\n\nsparsematrix: SparseArrays.AbstractSparseMatrixCSC or SparseMatricesCSR.SparseMatrixCSR. \nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nverbose: if true, print generated JSON string passed to amgcl.\nparam:   Ignored if nothing (default). Otherwise, any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write.\ncoarsening: A coarsening strategy\nrelax: A relaxation method\n\n\n\n\n\n","category":"type"},{"location":"preconditioners/#AMGCLWrap.AMGPreconditioner","page":"Preconditioners","title":"AMGCLWrap.AMGPreconditioner","text":"struct AMGPreconditioner\n\nPreconditioner strategy (e.g. for the new precs kwarg in LinearSolve) for interfacing AMGPrecon.\n\nFields (for documentation, see AMGPrecon):\n\nparam::Any\nverbose::Bool\nblocksize::Int64\ncoarsening::Union{AMGCLWrap.AbstractCoarsening, NamedTuple}\nrelax::Union{AMGCLWrap.AbstractRelaxation, NamedTuple}\n\n\n\n\n\n","category":"type"},{"location":"preconditioners/#AMGCLWrap.RLXPrecon","page":"Preconditioners","title":"AMGCLWrap.RLXPrecon","text":"RLXPrecon(sparsematrix::AbstractSparseMatrix; \n             blocksize=1, \n             param=nothing)\n\nCreate single level relaxation preconditioner with ldiv! and \\ methods solving the preconditioning system.\n\nParameters:\n\nsparsematrix: SparseArrays.AbstractSparseMatrixCSC or SparseMatricesCSR.SparseMatrixCSR. \nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of        blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nparam: Any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write. If params is an emtpy string or nothing a default value is used.\n\n\n\n\n\nRLXPrecon(sparsematrix::AbstractSparseMatrix;\n          blocksize::Int=1,\n          param=nothing,\n          verbose::Bool=false,\n          precond::Union{AbstractRelaxation, NamedTuple}=ILU0Relaxation())\n\nCreate single level relaxation preconditioner with ldiv! and \\ methods solving the preconditioning system.\n\nParameters:\n\nsparsematrix: SparseArrays.AbstractSparseMatrixCSC or SparseMatricesCSR.SparseMatrixCSR. \nblocksize: If blocksize >1, group unknowns into blocks of given size and cast the matrix internally to a sparse matrix of blocksize x blocksize static matrices. Block sizes 1...8 are instantiated.\nverbose: if true, print generated JSON string passed to amgcl.\nparam:   Ignored if nothing (default). Otherwise, any object (e.g. Tuple, Dict or JSON string) which can be turned into a JSON string by JSON3.write.\nprecond: A preconditioning method\n\n\n\n\n\n","category":"type"},{"location":"preconditioners/#AMGCLWrap.RLXPreconditioner","page":"Preconditioners","title":"AMGCLWrap.RLXPreconditioner","text":"struct RLXPreconditioner\n\nPreconditioner strategy (e.g. for the new precs kwarg in LinearSolve) for interfacing RLXPrecon.\n\nFields (for documentation, see RLXPrecon):\n\nparam::Any\nverbose::Bool\nblocksize::Int64\nprecond::Union{AMGCLWrap.AbstractRelaxation, NamedTuple}\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"AMGCLWrap","category":"page"},{"location":"#AMGCLWrap","page":"Home","title":"AMGCLWrap","text":"AMGCLWrap\n\nAMGCLWrap\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Aqua QA)\n\nJulia wrapper around a subset of AMGCL via the C wrapper AMGCL_C.\n\nIf you find this package useful, please  give credits to the author of AMGCL.\n\n\n\n\n\n","category":"module"},{"location":"parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"AMGCLWrap.AbstractAMGCLParams","category":"page"},{"location":"parameters/#AMGCLWrap.AbstractAMGCLParams","page":"Parameters","title":"AMGCLWrap.AbstractAMGCLParams","text":"abstract type AbstractAMGCLParams\n\nAbstract parameter type.\n\n\n\n\n\n","category":"type"},{"location":"parameters/#Iterative-solver-strategies","page":"Parameters","title":"Iterative solver strategies","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"See the Iterative Solvers section of the AMGCL documentation.","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"Instead of one of the solvers below, a named tuple like (type= \"cg\", tol=1.0e-10) can be passed. This also allows to use methods not accessible via one of the structures defined below. ","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"AMGCLWrap.AbstractSolver\nAMGCLWrap.BICGStabSolver\nAMGCLWrap.CGSolver\nAMGCLWrap.GMRESSolver","category":"page"},{"location":"parameters/#AMGCLWrap.AbstractSolver","page":"Parameters","title":"AMGCLWrap.AbstractSolver","text":"abstract type AbstractSolver <: AMGCLWrap.AbstractAMGCLParams\n\nAbstract solver parameter type.\n\n\n\n\n\n","category":"type"},{"location":"parameters/#AMGCLWrap.BICGStabSolver","page":"Parameters","title":"AMGCLWrap.BICGStabSolver","text":"struct BICGStabSolver <: AMGCLWrap.AbstractSolver\n\nBICGStab solver\n\ntype::String\npside::String\ntol::Float64\nabstol::Float64\nmaxiter::Int64\nverbose::Bool\n\n\n\n\n\n","category":"type"},{"location":"parameters/#AMGCLWrap.CGSolver","page":"Parameters","title":"AMGCLWrap.CGSolver","text":"struct CGSolver <: AMGCLWrap.AbstractSolver\n\ntype::String\ntol::Float64\nabstol::Float64\nmaxiter::Int64\nverbose::Bool\n\n\n\n\n\n","category":"type"},{"location":"parameters/#AMGCLWrap.GMRESSolver","page":"Parameters","title":"AMGCLWrap.GMRESSolver","text":"struct GMRESSolver <: AMGCLWrap.AbstractSolver\n\ntype::String\nM::Int64\npside::String\ntol::Float64\nabstol::Float64\nmaxiter::Int64\nverbose::Bool\n\n\n\n\n\n","category":"type"},{"location":"parameters/#Relaxation-strategies","page":"Parameters","title":"Relaxation strategies","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"See the Relaxation section of the AMGCL documentation.","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"Instead of one of the strategies below, a named tuple like (type= \"damped_jacobi\", damping=0.72) can be passed. This also allows to use methods not accessible via one of the structures defined below. ","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"AMGCLWrap.AbstractRelaxation\nAMGCLWrap.ILU0Relaxation\nAMGCLWrap.SPAI0Relaxation","category":"page"},{"location":"parameters/#AMGCLWrap.AbstractRelaxation","page":"Parameters","title":"AMGCLWrap.AbstractRelaxation","text":"abstract type AbstractRelaxation <: AMGCLWrap.AbstractAMGCLParams\n\nAbstract relaxation parameter type.\n\n\n\n\n\n","category":"type"},{"location":"parameters/#AMGCLWrap.ILU0Relaxation","page":"Parameters","title":"AMGCLWrap.ILU0Relaxation","text":"struct ILU0Relaxation <: AMGCLWrap.AbstractRelaxation\n\ntype::String\n\n\n\n\n\n","category":"type"},{"location":"parameters/#AMGCLWrap.SPAI0Relaxation","page":"Parameters","title":"AMGCLWrap.SPAI0Relaxation","text":"struct SPAI0Relaxation <: AMGCLWrap.AbstractRelaxation\n\ntype::String\n\n\n\n\n\n","category":"type"},{"location":"parameters/#Coarsening-strategies","page":"Parameters","title":"Coarsening strategies","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"See the Coarsening Strategies section of the AMGCL documentation.","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"Instead of one of the strategies below, a named tuple like (type= \"smoothed_aggregation\", relax=1.0) can be passed. This also allows to use methods not accessible via one of the structures defined below. ","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"AMGCLWrap.AbstractCoarsening\nAMGCLWrap.RugeStubenCoarsening\nAMGCLWrap.SmoothedAggregationCoarsening","category":"page"},{"location":"parameters/#AMGCLWrap.AbstractCoarsening","page":"Parameters","title":"AMGCLWrap.AbstractCoarsening","text":"abstract type AbstractCoarsening <: AMGCLWrap.AbstractAMGCLParams\n\nAbstract coarsening parameter type.\n\n\n\n\n\n","category":"type"},{"location":"parameters/#AMGCLWrap.RugeStubenCoarsening","page":"Parameters","title":"AMGCLWrap.RugeStubenCoarsening","text":"struct RugeStubenCoarsening <: AMGCLWrap.AbstractCoarsening\n\ntype::String\neps_strong::Float64\ndo_trunc::Bool\neps_trunc::Float64\n\n\n\n\n\n","category":"type"},{"location":"parameters/#AMGCLWrap.SmoothedAggregationCoarsening","page":"Parameters","title":"AMGCLWrap.SmoothedAggregationCoarsening","text":"struct SmoothedAggregationCoarsening <: AMGCLWrap.AbstractCoarsening\n\ntype::String\nrelax::Float64\n\n\n\n\n\n","category":"type"}]
}
